// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRecording = `-- name: CreateRecording :exec
insert into recordings (id, login, created_at, ready, title, category, language, viewers, stream_started_at)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateRecordingParams struct {
	ID              pgtype.UUID
	Login           string
	CreatedAt       pgtype.Timestamp
	Ready           bool
	Title           string
	Category        string
	Language        string
	Viewers         int32
	StreamStartedAt pgtype.Timestamp
}

func (q *Queries) CreateRecording(ctx context.Context, arg CreateRecordingParams) error {
	_, err := q.db.Exec(ctx, createRecording,
		arg.ID,
		arg.Login,
		arg.CreatedAt,
		arg.Ready,
		arg.Title,
		arg.Category,
		arg.Language,
		arg.Viewers,
		arg.StreamStartedAt,
	)
	return err
}

const getStreamerRecordings = `-- name: GetStreamerRecordings :many
select id, login, created_at, ready, title, category, language, viewers, stream_started_at
from recordings
where login = $1
`

func (q *Queries) GetStreamerRecordings(ctx context.Context, login string) ([]Recording, error) {
	rows, err := q.db.Query(ctx, getStreamerRecordings, login)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recording
	for rows.Next() {
		var i Recording
		if err := rows.Scan(
			&i.ID,
			&i.Login,
			&i.CreatedAt,
			&i.Ready,
			&i.Title,
			&i.Category,
			&i.Language,
			&i.Viewers,
			&i.StreamStartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecording = `-- name: UpdateRecording :one
update recordings
set login               = coalesce($1, login),
    created_at          = coalesce($2, created_at),
    ready               = coalesce($3, ready),
    title               = coalesce($4, title),
    category            = coalesce($5, category),
    language            = coalesce($6, language),
    viewers             = coalesce($7, viewers),
    stream_started_at   = coalesce($8, stream_started_at)
where id = $9
returning id
`

type UpdateRecordingParams struct {
	Login           pgtype.Text
	CreatedAt       pgtype.Timestamp
	Ready           pgtype.Bool
	Title           pgtype.Text
	Category        pgtype.Text
	Language        pgtype.Text
	Viewers         pgtype.Int4
	StreamStartedAt pgtype.Timestamp
	RecordingID     pgtype.UUID
}

func (q *Queries) UpdateRecording(ctx context.Context, arg UpdateRecordingParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, updateRecording,
		arg.Login,
		arg.CreatedAt,
		arg.Ready,
		arg.Title,
		arg.Category,
		arg.Language,
		arg.Viewers,
		arg.StreamStartedAt,
		arg.RecordingID,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
